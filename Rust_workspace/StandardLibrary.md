### 標準ライブラリ

本テキストは、Rustを学習していく中で使用する標準ライブラリについて、記載していく。

詳細は、[標準ライブラリの公式ドキュメント](https://doc.rust-lang.org/stable/std/)を参照のこと。

### BufReader<R>

  - Description

    BufReader<R>構造体は、任意のReaderにバッファを追加する。

    Readインスタンスを直接操作するのは非常に非効率である。例えば、TCPStreamで読み取りを呼び出す度にシステムコールが発生します。BufReader<R>は、一度にある程度の量を読み取り、その結果をメモリ内のバッファに保持する。

    BufReader<R>が削除されると、そのバッファの内容が破棄する。

    同じストリーム上に複数のBufReader<R>のインスタンスを作成すると、データが損失する可能性がある。

    BufReader::into_innerでBufReaderをunwrapしたあと、基となるReaderから読み取りを行うと、データを損失することがある。

  - Example

    ~~~rust
    use std::io::prelude::*;
    use std::io::BufReader;
    use std::fs::File;
    
    fn main() -> std::io::Result<()> {
        let f = File::open("log.txt")?;
        let mut reader = BufReader::new(f);
    
        let mut line = String::new();
        let len = reader.read_line(&mut line)?;
        println!("First line is {} bytes long", len);
        Ok(())
    }
    ~~~

  - new関連関数

    デフォルトのバッファ容量を持つ新しい BufReader<R> を作成する。デフォルトは現在 8 KB 。

### std::io::Read::read

- Description

  このソースからいくつかのバイトを指定されたバッファに引き込み、何バイト読まれたかを返します。

  この関数は、データの待ち受けをブロックするかどうかについては何の保証もしませんが、オブジェクトが読み込みのためにブロックする必要があり、ブロックできない場合は、通常は`Err`返り値を介してその旨を通知します。

  このメソッドの戻り値が Ok(n) である場合、`0 <= n <= buf.len()`であることが保証されなければなりません。ゼロでない`n`の値は、バッファ`buf `がこのソースからの`n`バイトのデータで埋め尽くされたことを示します。`n`が 0 の場合は、2 つのシナリオのうちの 1 つを示します。

### AsRef

  - Description

    簡単な参照間変換を行う。

    このトレイトは、可変参照間の変換に使用される`FnMut`に似ている。

    もし、高度な変換を行う必要がある場合は、`From`を&T型で実装するか、カスタム関数を実装するほうがよい。

    AsRefは、参照と同じシグネチャを持っていますが、いくつか異なる点がある。

     - AsRefとは異なり、参照は任意のTに対してブランケット実装(トレイト境界を満たすあらゆる型にトレイトを実装すること)を持っており、参照または値のどちらかを受け取るために使用できる

     - 参照では、参照した値の[Hash]、[Eq]、[Ord]が同等であることが要求される

     - 構造体の単一フィールドのみを借用したい場合はAsrefを実施できますが、参照は実装できない。

    

    ​	Note:このトレイトは失敗することができない。変換に失敗する可能性がある場合は、Option<T>または      			 Result<T, E>を返す専用のメソッドを使用すること。

   - Generic Implementations

     AsRef は、内部の型が参照または変異可能な参照である場合に自動参照を行う (例: foo.as_ref() は、foo が &mut Foo または &&mut Foo の型を持っていても同じように動作する)。

  - Example

  ~~~rust
  fn is_hello<T: AsRef<str>>(s: T) {
     assert_eq!("hello", s.as_ref());
  }
  
  let s = "hello";
  is_hello(s);
  
  let s = "hello".to_string();
  is_hello(s);
  ~~~

### Path

  - Discription

    パスのスライス。

    この型はパスを検査するための多くの操作をサポートしている。パスをその構成要素に分割したり(Unixでは/で区切って、Windowsでは/または/で区切って)、ファイル名を抽出したり、パスが絶対パスかどうかを判断したりなど。

    非サイズ型であり、常に 参照 や [Box] のようなポインタの後ろで使用されなければならない。

### File::open

  - Description

    読み取り専用でファイルを開く。

    この関数は、パスが既に存在しない場合にエラーを返す。

### std::fs::write

- Descriptiom

  スライスをファイルの内容全体として書き込みます。

  この関数は、ファイルが存在しない場合にはファイルを作成し、存在する場合にはその内容を完全に置き換えます。

  これは、`File::create`や`write_all`を使用してインポートを少なくするための便利な関数です。

  - Example

    ~~~rust
    use std::fs;
    
    fn main() -> std::io::Result<()> {
        fs::write("foo.txt", b"Lorem ipsum")?;
        fs::write("bar.txt", "dolor sit")?;
        Ok(())
    }
    ~~~

### std::io::Write

  - Description

    バイト指向のシンクであるオブジェクトのためのトレイト。

    `Write`トレイト の実装者は`writers`と呼ばれることもあります。

    ライターは `write`と`flush`の 2 つのメソッドで定義されています。

    `write`メソッドは、オブジェクトにデータを書き込もうとし、何バイト書き込まれたかを返します。

    `flush`メソッドは、アダプタや明示的なバッファ自体が、バッファリングされたデータがすべて「真のシンク」に押し出されたことを確認するために便利です。

    ライタは、お互いに互換性があるように設計されています。`std::io`の多くの実装では、`Write`トレイトを実装した型を取り、提供しています。

  - flush

    この出力ストリームをフラッシュし、中間的にバッファリングされたすべてのコンテンツが目的地に到達するようにします。

    - Errors
      I/OエラーやEOFに達しているため、すべてのバイトが書き込めなかった場合はエラーとなります。


### BufRead::lines

  - Description

    Readerの行のイテレータを返す。

    この関数から返されるイテレータは、io::Result<[String]>のインスタンスを返します。返される各文字列は、最後に改行バイト（0xAバイト）やCRLF（0xD、0xAバイト）は持たない。

### str::lines

  - Description

    各行の文字列を文字列スライスとして、イテレータを返す。

    行は、改行（\ n）または改行によるキャリッジリターン（\ r \ n）のいずれかで終了する。

    最終行終了はオプションである。最終行終了で終わる文字列は、最終行終了のない、そうでなければ同一の文字列と同じ行を返す。

### std::env::Args

  - Description

    プロセスの引数に対するイテレータで、各引数の String 値を返す。
    この構造体は`env::args()`によって作成される。詳細はドキュメントを参照のこと。
    最初の要素は伝統的に実行ファイルのパスですが、任意のテキストを設定することもでき、存在しない場合もある。つまり、このプロパティはセキュリティのために頼るべきではないということである。

### std::env::args

  - Description

    このプログラムが開始されたときの引数を返す（通常はコマンドライン経由で渡される）

### nth(n)

  - Description

    イテレータの n 番目の要素を返す。

    ほとんどのインデックス操作と同様に、カウントはゼロから始まるので、 nth(0) は最初の値を返し、 nth(1) は 2 番目の値を返す。

    返された要素と同様に、先行するすべての要素がイテレータから消費されることに注意すること。つまり、先行する要素は破棄され、同じイテレータで nth(0) を複数回呼び出すと、異なる要素が返されることになる。

    nth() は、n がイテレータの長さ以上であれば [None] を返す。

### std::cmp::PartialEq

  - Description

    半同値関係にある等式の比較を行うトレイト。

    このトレイトは、完全な等価関係を持たない型に対して、部分的な等価関係を可能にします。

    例えば、浮動小数点では`Nan! = Nan`なのでPartialEqを実装していますが、Eqは実装していない。

    形式的には、(すべてのa,b,cに対して)等価でなければならない。

    対称的： a == b は b == a を意味する。
    推移的: a == b と b == c は a == c を意味する。
    これらの要件は、トレイト自体が対称的かつ推移的に実装されなければならないことを意味していることに注意すること。

    もし T: PartialEq<U> と  U: PartialEq<V> の場合、 U: PartialEq<T> と T: PartialEq<V>となる。

    このトレイトは、#[derive]と一緒に使うことができる。構造体で導出された場合、すべてのフィールドが等しい場合は2つのインスタンスが等しく、いずれかのフィールドが等しくない場合は等しくない。enumsで導出された場合、各バリアントはそれ自身と等しく、他のバリアントとは等しくない。

    PartialEq は eq メソッドを実装する必要があるだけで、PartialEqはeqメソッドを使用して定義されている。

    を手動で実装する場合は、eq は PartialEq  の厳密な逆数であるというルールを守らなければならない。

    つまり、`a != b`の場合に限り`!(a==b)`

    PartialEq、PartialOrd、Ord の実装は互いに一致していなけならない。いくつかのトレイトを導出し、他のトレイトを手動で実装することで、誤ってこれらのトレイトを一致させてしまうことは簡単である。

  - Example

    フォーマットが異なっていても、ISBN が一致していれば 2 冊の本が同じ本とみなされるドメインの実装例。

    ~~~rust
    enum BookFormat {
        Paperback,
        Hardback,
        Ebook,
    }
    
    struct Book {
        isbn: i32,
        format: BookFormat,
    }
    
    impl PartialEq for Book {
        fn eq(&self, other: &Self) -> bool {
            self.isbn == other.isbn
        }
    }
    
    let b1 = Book { isbn: 3, format: BookFormat::Paperback };
    let b2 = Book { isbn: 3, format: BookFormat::Ebook };
    let b3 = Book { isbn: 10, format: BookFormat::Paperback };
    
    assert!(b1 == b2);
    assert!(b1 != b3);
    ~~~

### std::clone::Clone

  - Description

    オブジェクトを明示的に複製することができる共通のトレイト

    Copyとの違いは、Copyは暗黙的で非常に安価であるのに対して、Cloneは常に明示的あり、高価であるときもあればそうでないときもある点である。これらの特C徴を強制するために、RustではCopyは再実装できませんが、Cloneを再実装して任意のコードに対してい再実行できる。

    CloneはCopyよりも一般的なので、Copyであればなんでも自動的にCloneにすることができる。

    このトレイトは、すべてのフィールドがCloneであれば#[derive]で使用できます。Cloneの派生実装は、各フィールドでcloneを呼び出す。

    一般的な構造体の場合、#[derive]は一般的なパラメータにバインドされたCloneを追加することで条件付きでCloneを実装する。

### std::iter::FromIterator

  - Description

    型に対して FromIterator を実装することで、イテレータからどのように生成されるかを定義する。

    FromIterator::from_iter() が明示的にコールされることはほとんどなく、代わりに Iterator::collect() メソッドを使用する(詳細は、[Iterator::collect()](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect)を参照)

###  Iterator::collect

  - Description

    イテレータをコレクションに変換する。

    collect() は、イテレータ可能なものなら何でも受け取り、関連するコレクションに変換することができる。これは標準ライブラリの中でも最も強力なメソッドのひとつで、さまざまなコンテキストで使用されている。

    collect() が使用される最も基本的なパターンは、あるコレクションを別のコレクションに変換すること。コレクションを取得し、それに対して iter を呼び出し、多くの変換を行い、最後に collect() を行う。

    collect() は、一般的なコレクションではない型のインスタンスを作成することもできる。例えば、文字列から String を作成したり、Result<T, E> アイテムのイテレータを Result<Collection<T>, E> に収集したりすることができる。詳細は[例](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect)を参照のこと。

    collect() は非常に一般的なので、型推論の問題を引き起こす可能性がある。そのため、collect() は「ターボフィッシュ」: ::<> として親しまれている構文を目にすることができる数少ないもののひとつである。これは、推論アルゴリズムがどのコレクションにコレクションしようとしているのかを具体的に理解するのに役立つ。

### std::iter::Iterator::next

  - Description

    イテレータを進めて次の値を返す。反復が終了すると [None] を返す。個々のイテレータの実装は、反復処理を再開することを選択することができる。

### std::iter::Iterator::filter

  - Description

    クロージャを使用して要素を生成するかどうかを決定するイテレータを作成する。
    要素が与えられると、クロージャは true または false を返さなければならない。返されるイテレータは、クロージャが true を返す要素のみを返す。

### read_to_string()

  - Description

    End of Fileまですべてのバイトを読み込みバッファに追加する。

    成功した場合、この関数は読み込んでバッファに追加したバイト数を返却する。

    このストリーム内のデータが有効なUTF-8でない場合、エラーを返却し、バッファに追加されない。

    そのほかの、エラーセマンティクスは[read_to_end](https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.read_to_end)を参照のこと。

### std::process

  - Description

    プロセスを扱うモジュール。

    このモジュールは、主に子プロセスの生成と相互作用に関係していますが、現在のプロセスを終了させるための [abort] と [exit] も提供している。

### std::process::exit

  - Description

    指定した終了コードで現在のプロセスを終了させる。

    この関数は何も返却せず、現在のプロセスを即座に終了させる。終了コードは基盤となるOSに渡され、別のプロセスで使用できるようになる。

    この関数は何も返却せず、プロセスを終了するので、現在のスタックや他のスレッドのスタック上のデストラクタは実行されないことに注意すること。クリーンなシャットダウンが必要な場合は、実行するデストラクタがなくなった時点でのみこの関数を呼び出すことを検討すること。

### unwrap_or_else

  - Description

    標準ライブラリで`Result<T, E>`に定義されている。

    unwrap_or_elseを使用することで、panic!ではない独自のエラーを返すことでができる。

    Result<T,E>の結果がOkであれば、Okが包んでいる値を返却する(unwrapに似ている)

    値がErr値なら、このメソッドはクロージャ内でコードを呼び、クロージャに定義した引数としてunwrap_or_elseに渡す匿名関数である。

### String

  - Description

    UTF-8エンコードされた可変長文字列

    String型は、文字列の内容を所有する最も一般的な文字列型。これは、その借用型であるプリミティブ 型のstr型 と密接な関係を持っている。

    表.String型とstr型

    | 型       | 役割                | 実データを格納するメモリ領域                               | 文字の変更 | 文字の追加・削除 | 実データを所有しているか |
    | -------- | ------------------- | ---------------------------------------------------------- | ---------- | ---------------- | ------------------------ |
    | String   | 可変長のUTF-8文字列 | ヒープ領域                                                 | 可         | 可               | 所有する                 |
    | &str     | 固定長のUTF-8文字列 | ヒープ領域、スタック領域、静的領域のいずれか。参照先に依存 | 不可       | 不可             | 所有しない               |
    | &mut str | 固定長のUTF-8文字列 | ヒープ領域、スタック領域、静的領域のいずれか。参照先に依存 | 可         | 不可             | 所有しない               |

    ※&strは不変スライス経由のアクセス、&mut strは可変スライス経由のアクセス

- String::from_utf8_lossy

  無効な文字を含むバイトのスライスを文字列に変換します。

  文字列はバイト([u8])でできており、バイトのスライス(&[u8])はバイトでできているので、この関数は両者を変換します。ただし、すべてのバイトスライスが有効な文字列であるわけではありません: 文字列は有効なUTF-8である必要があります。この変換の際、`from_utf8_lossy()`は無効な UTF-8 シーケンスを`U+FFFD REPLACEMENT CHARACTER`で置き換えます。

  バイトスライスが有効なUTF-8であることが確実で、変換のオーバーヘッドを発生させたくない場合は、この関数の安全でないバージョンである`from_utf8_unchecked`があります。

  この関数は`Cow<'a, str>`を返します。バイトスライスが無効なUTF-8であれば、置換文字を挿入する必要がありますが、これは文字列のサイズを変えることになるので、Stringが必要になります。しかし、すでに有効なUTF-8であれば、新しい割り当ては必要ありません。この戻り値型は、両方のケースを処理することができます。

### 配列を表現する型

  - Description

    以下に配列を表現する型として、配列、スライス、ベクタについてまとめる

    表.配列を表現する型

    | 型                                 | 役割                             | 実データを格納するメモリ領域                 | 要素数が決定されるタイミング | 要素の追加・削除 | 実データを所有するか |
    | ---------------------------------- | -------------------------------- | -------------------------------------------- | ---------------------------- | ---------------- | -------------------- |
    | ベクタVec<T>                       | サイズ可変の配列                 | ヒープ領域                                   | 実行時                       | 可               | 所有する             |
    | 配列[T; n]                         | サイズ固定の配列                 | スタック領域                                 | コンパイル時(型に現れる)     | 不可             | 所有する             |
    | ボックス化されたスライスBox<[T]>   | サイズ固定の配列                 | ヒープ領域                                   | 実行時                       | 不可             | 所有する             |
    | そのほかのスライス(&[T]、&mut [T]) | ベクタや配列へのアクセスを抽象化 | ヒープ領域、またはスタック領域。参照先に依存 | 実行時                       | 不可             | 所有しない           |

### dynキーワード

  - Description

    `dyn` は trait オブジェクトの型の接頭辞である

    `dyn`キーワードは、関連付けられた Trait のメソッドの呼び出しが動的にディスパッチされることを強調するために使用する。このように trait を使用するには、それが `object safe` である必要がある。
    一般的なパラメータや`impl Trait`とは異なり、コンパイラは渡される具体的な型を推論できない。つまり、型は消去されている。そのため、`dyn Trait`参照には2つのポインタが含まれている。
    1つのポインタはデータ(構造体のインスタンスなど)へのポインタ。もう 1 つのポインタは、メソッド呼び出し名と関数ポインタのマップ(仮想メソッドテーブルまたは vtable として知られている)へのポインタです。
    実行時に、`dyn Trait`上でメソッドを呼び出す必要がある場合、関数ポインタを取得するために`vtable`が参照され、その関数ポインタが呼び出される。

    - トレードオフ

      上記は間接的には、`dyn Trait`上で関数を呼び出す際の追加の実行コストである。動的ディスパッチによって呼び出されたメソッドは、一般的にコンパイラによってインライン化することができない。
      しかし、具体的な型ごとにメソッドが重複しないため、`dyn Trait`は`impl Trait / generic parameters` よりも小さなコードを生成する可能性がある。
      オブジェクトの安全性と traitオブジェクトについての詳細は[こちら](https://doc.rust-lang.org/stable/book/ch17-02-trait-objects.html)を参照。

### str::contains

  - Description

    与えられたパターンが、この文字列スライスのサブスライスにマッチした場合に真を返す。
    そうでない場合は false を返す。
    パターンには、&str、char、文字列のスライス、文字がマッチするかどうかを判定する関数やクロージャを指定することができる。

### std::error::Error

  - Description

    エラーは、エラー値、すなわち`Result<T, E>`の E 型の値に対する基本的な期待値を表すトレイトである。
    エラーは、表示とデバッグのトレイトを通して自分自身を記述しなければならず、原因の連鎖情報を提供することができる。
    `Error::source()`は、一般的にエラーが「抽象化の境界」を越える場合に使用される。
    あるモジュールが下位レベルのモジュールからのエラーによって引き起こされたエラーを伝えなければならない場合、 [Error::source()](https://doc.rust-lang.org/stable/std/error/trait.Error.html#method.source)を介してそのエラーにアクセスできるようにすることができる。これにより、上位モジュールが独自のエラーを提供することが可能になり、同時にソースチェーンを介してデバッグ用の実装の一部を公開することも可能になる。

### str::to_lowercase

  - Description

    この文字列スライスの小文字に相当するものを、新しい [String] として返す。
    `Lowercase`は、Unicode Derived Core Property Lowercaseの条項に従って定義される。
    大文字小文字を変更すると複数の文字に展開されてしまう文字があるため、この関数はパラメータをそのまま変更するのではなく、[String]として返す。

### env::var

  - Description

    現在のプロセスから環境変数のキーを取得する。

    

### [std::result::Result::is_err](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.is_err)

  - Description

    結果が`Err`なら`true`を返す。

### std::thread

  - Description

    - The threading model
      実行中のRustプログラムは、ネイティブOSのスレッドのコレクションで構成されており、それぞれが独自のスタックとローカルステートを持っている。
      スレッドは名前を付けることができ、低レベルの同期のためのいくつかの組み込みサポートを提供している。
      スレッド間の通信は、チャンネル、Rust のメッセージ通過型、他の形式のスレッド同期、共有メモリデータ構造を介して行うことができる。特に、スレッドセーフであることが保証されている型は、原子的に参照カウントされたコンテナ`Arc`を使用してスレッド間で簡単に共有することができる。
      Rust で致命的なロジックエラーが発生すると、スレッドパニックが発生し、その間にスレッドはスタックを巻き戻し、デストラクタを実行し、所有するリソースを解放します。これは、スレッドがスタックを巻き戻し、デストラクタを実行し、所有するリソースを解放することを意味する。パニックが捕捉されなかった場合、スレッドは終了しますが、オプションで`join`を使用して別のスレッドからパニックを検出することができる。パニックが捕捉されずにメインスレッドがパニックに陥った場合、アプリケーションは0以外の終了コードで終了します。
      Rust プログラムのメインスレッドが終了すると、他のスレッドが実行中であってもプログラム全体がシャットダウンします。しかし、このモジュールは自動的に子スレッドの終了を待つための便利な機能を提供している。
    - Spawning a thread
      新しいスレッドは`thread::spawn`関数を使って生成することができる。

    ~~~rust
    use std::thread;
    
    thread::spawn(move || {)
        // some work here
    });
    ~~~

    ​	この例では、スポーンされたスレッドは現在のスレッドから「切り離された」状態になっている。これは、	この親がメインスレッドでない限り、その親 (それをスポーンしたスレッド) よりも長生きできることを意味	する。
    ​	親スレッドは子スレッドの完了を待つこともできます。

    ​	spawn の呼び出しは`JoinHandle`を生成する。

    ~~~rust
    use std::thread;
    
    let child = thread::spawn(move || {
        // some work here
    });
    // some work here
    let res = child.join();
    ~~~

    ​		joinメソッドは、子スレッドが生成した最終的な値のOkを含む`thread::Result`を返し、子スレッドがパニ		ックに陥った場合は`panic!`コールに与えられた値のErrを返す。

    - Configuring threads
      新しいスレッドは、ビルダータイプを介してスポーンされる前に設定することができ、現在のところ子スレッドの名前とスタックサイズを設定することができる。

    ~~~rust
    use std::thread;
    
    thread::Builder::new().name("child1".to_string()).spawn(move || {
        println!("Hello, world!");
    });
    ~~~


    - Spawning a thread
      スレッドは、2 つの方法のいずれかで取得できる Thread 型を介して表現される。
    
      例えば、thread::spawn 関数を使用して新しいスレッドを生成し、`JoinHandle`で thread を呼び出す。


      - thread::current 関数を使用して、現在のスレッドを要求する。
      - thread::current 関数は、このモジュールの API によってスポーンされないスレッドに対しても利用可能。
    
    - Thread-local storage
      このモジュールは、Rust プログラム用のスレッドローカルストレージの実装も提供する。スレッドローカルストレージは、プログラム内の各スレッドが独自のコピーを持つグローバル変数にデータを格納する方法。スレッドはこのデータを共有しないので、アクセスを同期させる必要はない。
    
      スレッドローカルキーは、それが含む値を所有し、スレッドが終了したときにその値を破棄します。thread_local! マクロで作成され、`'static`(借用ポインタはない)な値を含むことができる。これは、指定されたクロージャへの値への共有参照を生成するアクセサ関数`with`を提供します。スレッドローカルキーは、値への共有アクセスのみを許可している。ほとんどの値は、Cell型やRefCell型を用いて何らかの形式の内部変異性を利用したいと考えるであろう。
    
    - Naming threads
      スレッドは、識別のために関連付けられた名前を持つことができる。デフォルトでは、スポーンされたスレッドには名前が付けられていない。スレッドの名前を指定するには、`Builder`でスレッドをビルドし、希望するスレッド名を Builder::name に渡します。スレッド名をスレッド内から取得するには Thread::name を使用します。スレッド名が使用される例をいくつか挙げます。


      - 指定されたスレッドでパニックが発生した場合、そのスレッド名がパニックメッセージに表示される。
      - スレッド名は、該当する場合には OS に提供される (例: unix ライクなプラットフォームでは pthread_setname_np)。
    
    - Stack size
      スポーンされるスレッドのデフォルトのスタックサイズは 2 MiB ですが、この特定のスタックサイズは将来的に変更される可能性がある。スポーンされるスレッドのスタックサイズを手動で指定するには、2つの方法がある。
    
    - Stack size
      Builder でスレッドをビルドし、希望するスタックサイズを`Builder::stack_size`に渡す。
      環境変数 RUST_MIN_STACK を、希望するスタックサイズを表す整数 (バイト単位)に設定する。`Builder::stack_size`の設定はこれをオーバーライドすることに注意。
      メインスレッドのスタックサイズは Rust によって決定されないことに注意。

### std::time::Duration

  - Description

    Durationは、通常システムのタイムアウトに使用される時間のスパンを表す。
    各Durationは、秒の整数とナノ秒で表される端数で構成される。基礎となるシステムがナノ秒レベルの精度をサポートしていない場合、システム タイムアウトをバインディングするAPIは通常、ナノ秒数を切り上げる。
    Durationは、Add、Sub、その他のopsトレイトなど、多くの一般的なトレイトを実装している。長さ0のDurationを返すことでDefaultを実装している。

### std::thread::JoinHandle::join

  - Description

    関連するスレッドの終了を待つ。
    アトミックメモリの順序付けの観点からは、関連付けられたスレッドの完了は、この関数のリターンと同期する。
    言い換えれば、そのスレッドによって実行されたすべての操作は、joinが戻ってきた後に発生するすべての操作よりも先に順序付けられる。
    子スレッドがパニックに陥った場合、`panic！`に与えられたパラメータで`Err`が返される。
    この関数は、プラットフォームによってはスレッドが自分自身に参加しようとした場合にパニックを起こすかもしれないし、そうでなければスレッドの参加でデッドロックを起こすかもしれない。

### std::thread::sleep

  - Description

    現在のスレッドを、少なくとも指定した時間だけスリープ状態にする。
    スレッドは、スケジューリングの仕様やプラットフォーム依存の機能のために、指定された時間よりも長くスリープすることがある。スレッドのスリープ時間が短くなることはない。
    この関数はブロッキングであり、非同期関数では使用すべきではない。

### std::sync::mpsc

  - Description

    このモジュールは、3 つのタイプの中で具体的に定義されたチャネルを介したメッセージベースの通信を提供します。

    - 送信者

    - シンクロ送信者

    - 受信機

    `Sender`または`SyncSender`は、`Receiver`にデータを送信するために使用される。どちらの送信者もクローン可能（Multi-producer）で、多くのスレッドが同時に 1 つのレシーバに送信することができる（single-consumer）。

    これらのチャンネルには 2 つの種類があります。

    - 非同期で無限にバッファリングされたチャンネルです。チャンネル関数は (Sender, Receiver) タプルを返します。チャネルは、概念的には無限のバッファを持つ。

    - 同期的な、制限されたチャンネル。`sync_channel`関数は (SyncSender, Receiver) タプルを返す。バッファスペースが空くまでブロックすることで、すべての送信は同期的に行われる。`0`の束縛が許されているため、チャネルは "rendezvous" channel となり、各送信者がメッセージを受信者にアトム単位で渡すようになることに注意。

    Disconnection
    チャンネルの送受信操作はすべて、操作が成功したかどうかを示す結果を返します。操作が成功しなかった場合は、通常はチャンネルの残りの半分が対応するスレッドに落とされて「ハングアップ」したことを示している。
    チャネルの半分が割り当てられてしまうと、ほとんどの操作は進行を続けることができなくなるため、`Err`が返されます。多くのアプリケーションでは、このモジュールから返された結果をアンラップし続け、あるスレッドが予期せず死んでしまった場合には、スレッド間で失敗が伝播してしまう。

### mpsc::channel

  - Description

    新しい非同期チャンネルを作成し、送信者と受信者の半分を返す。`Sender`で送信されたすべてのデータは、送信された順に `Receiver`で利用可能になり、`send`が呼び出し元のスレッドをブロックすることはない(このチャンネルには "無限のバッファ" があり、バッファの限界に達するとブロックされる `sync_channel`とは異なる)。
    `Sender` をクローンして同じチャンネルに複数回送信することができますが、サポートされているのは 1 つの`Receiver`のみ。

    `Sender`で送信しようとしている間に`Receiver]`が切断された場合、送信メソッドは `SendError`を返す。同様に、`Sender`が`recv`しようとしているときに切断された場合、`recv`メソッドは`RecvError`を返す。

### std::sync::mpsc::Sender::send

  - Description

    このチャネルに値を送信しようとし、送信できなかった場合は値を返す。
    送信が成功した場合は、チャンネルの相手側ハングアップしていないと判断された場合。送信に失敗した場合は、対応するチャンネルが既に割り当て解除されている場合。`Err`の戻り値はデータを受信しないことを意味し、`Ok`の戻り値はデータを受信することを意味しないことに注意すること。この関数が`Ok`を返した直後に、対応するチャンネルがハングアップする可能性がある。
    このメソッドは、現在のスレッドをブロックすることはない。

### std::sync::mpsc::Receive::recv

  - Description

    この受信機で値の待ち受けを試み、対応するチャンネルがハングアップした場合はエラーを返す。
    この関数は、利用可能なデータがなく、より多くのデータを送信できる可能性がある場合、常に現在のスレッドをブロックする。対応する`Sender`(または`SyncSender`) にメッセージが送信されると、このレシーバはウェイクアップしてそのメッセージを返す。
    対応する`Sender`が切断された場合や、このコールがブロックされている間に切断された場合は、このコールはウェイクアップして`Err`を返し、このチャンネルではこれ以上メッセージを受信できないことを示す。ただし、チャネルはバッファリングされているので、切断前に送信されたメッセージは正しく受信される。

### std::sync::Mutex

  - Description

  共有データの保護に有用な相互排除プリミティブ
  このmutexは、ロックが利用可能になるのを待つスレッドをブロックする。`mutex`は静的に初期化したり、新しいコンストラクタを使って作成することもできます。各`mutex`には保護するデータを表す`type`パラメータがあります。データは`lock`と`try_lock`から返される RAII ガードを介してのみアクセスでき、`mutex`がロックされているときにのみデータにアクセスできることを保証する。

  - Poisoning
    このモジュールのmutexは「Poisoning」と呼ばれる戦略を実装しており、mutexを保持している間にスレッドがパニックになると、いつでもmutexがポイズニングされているとみなされます。一度mutexがポイズニングされると、他のすべてのスレッドはデータが汚染されている可能性が高いので、デフォルトではデータにアクセスできなくなります(何らかの不変量が保持されていない)。
    mutexの場合、これは`lock`メソッドと`try_lock`メソッドが、`mutex`がポイズンされたかどうかを示す `Result`を返すことを意味します。mutexのほとんどの使用法では、これらの結果を単に unwrap() して、無効な不変量が目撃されないようにスレッド間でパニックを伝播させる。
    しかし、ポイズンされたmutexは、基礎となるデータへのすべてのアクセスを妨げるものではない。`PoisonError`型には`into_inner`メソッドがあり、これはロックが成功したときに返されるはずのガードを返す。これにより、ロックがポイズンされているにもかかわらず、データへのアクセスが可能になる。



### std::sync::Mutex::lock

  - Description

    mutexを取得し、それが可能になるまで現在のスレッドをブロックします。

    この関数は、mutexを取得できるようになるまでローカルスレッドをブロックします。復帰時には、そのスレッドはロックが保持されている唯一のスレッドとなります。ロックのスコープ付きアンロックを可能にするために、`RAII`ガードが返されます。ガードがスコープ外になると、mutexはアンロックされる。
    既にロックを保持しているスレッドでmutexをロックする場合の正確な動作は未定義である。しかし、この関数は2回目の呼び出しでは戻りません(例えば、パニックやデッドロックになる可能性がある)。

    - Error
      このmutexを保持している間にこのmutexの他のユーザがパニックに陥った場合、この呼び出しはmutexを取得した後にエラーを返す。

    - Panic
      この関数は、現在のスレッドが既にロックを保持している場合に呼び出されるとパニックになる可能性がある。

### std::rc

 - Description

   シングルスレッドの参照カウントポインタ。`Rc`は`Reference Counted`の略。

   `Rc<T>`型は、ヒープに割り当てられたT型の値の共有所有権を提供する。Rc上でcloneを実行すると、ヒープ内の同じ値への新しいポインタが生成される。与えられたアロケーションへの最後のRcポインタが破棄されると、そのアロケーションに格納されている値(しばしば "内部値 "と呼ばれる)も破棄される。
   Rustの共有参照はデフォルトで突然変更されることを禁止しており、`Rc`も例外ではない。もし値の変更が必要な場合は、`Rc`の中に`Cell`や`RefCell`を包含してください。
   `Rc`は非アトミックな参照カウントを使用する。これはオーバーヘッドが非常に低いことを意味しますが、`Rc`はスレッド間で送信することができないため、`Rc`は`Send`を実装していない。その結果、Rustコンパイラはコンパイル時にスレッド間で`Rcs`を送信していないかどうかをチェックする。マルチスレッドでアトミックな参照カウントが必要な場合は、`sync::Arc`を使用すること。
   `downgrade`メソッドを使用して、所有していない`Weak`ポインタを作成することができる。`Weak`ポインタを`Rc`にアップグレードすることができますが、アロケーションに格納されている値が既にドロップされている場合は`None`を返します。言い換えれば、`Weak`ポインタはアロケーション内の値を保持しない。
   `Rc`ポインタ間のサイクルは決して解放されない。このため、`Weak`はサイクルを壊すために使用される。例えば、ツリーは親ノードから子ノードへの強いRcポインターを持ち、子ノードから親ノードへの弱いポインターを持つことができる。
   `Rc<T>`は自動的にTへの派生を行います（Deref traitで）ので、`Rc<T>`型の値で`T`のメソッドを呼び出すことができます。`T`のメソッドとの名前の衝突を避けるために、Rc<T>のメソッドは関連する関数であり、[完全修飾構文]で呼ばれる。

   ~~~rust
   use std::rc::Rc;
   
   let my_rc = Rc::new(());
   Rc::downgrade(&my_rc);
   ~~~

   `Clone`のようなトレイトの`Rc<T>`の実装も完全修飾構文を使って呼ばれることがあります。完全修飾構文を好む人もいれば、メソッド呼び出し構文を好む人もいます。

   ~~~rust
   use std::rc::Rc;
   
   let rc = Rc::new(());
   // Method-call syntax
   let rc2 = rc.clone();
   // Fully qualified syntax
   let rc3 = Rc::clone(&rc);
   ~~~

   `Weak<T>`は、内部の値が既に落とされている可能性があるため、Tへの自動参照は行わない。

   - Cloning references
     既存の参照カウントポインタと同じアロケーションへの新しい参照の作成は、Rc<T>とWeak<T>のために実装されたClone traitを使用して行われる。

   ~~~rust
   use std::rc::Rc;
   
   let foo = Rc::new(vec![1.0, 2.0, 3.0]);
   // The two syntaxes below are equivalent.
   let a = foo.clone();
   let b = Rc::clone(&foo);
   // a and b both point to the same memory location as foo.
   ~~~

   `Rc::clone(&from)`構文は、コードの意味をより明確に伝えることができるので、最も慣用的である。上の例では、この構文を使うと、このコードが`foo`の内容を丸ごとコピーするのではなく、新しい参照を作成していることがわかりやすくなる。

   - Example
     あるガジェットを所有者が所有している場合を考えてみる。ガジェットの所有者を特定できるようにしたいが、所有者を特定することはできない。しかし、複数のガジェットが同じオーナーに属している可能性があるため、ユニークなオーナーシップではこれを行うことができない。`Rc`では複数のガジェット間でオーナーを共有し、どのガジェットがポイントしている間もオーナーが割り当てられたままにしておくことができる。

   ~~~rust
   use std::rc::Rc;
   
   struct Owner {
       name: String,
       // ...other fields
   }
   
   struct Gadget {
       id: i32,
       owner: Rc<Owner>,
       // ...other fields
   }
   
   fn main() {
       // Create a reference-counted `Owner`.
       let gadget_owner: Rc<Owner> = Rc::new(
           Owner {
               name: "Gadget Man".to_string(),
           }
       );
   
       // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`
       // gives us a new pointer to the same `Owner` allocation, incrementing
       // the reference count in the process.
       let gadget1 = Gadget {
           id: 1,
           owner: Rc::clone(&gadget_owner),
       };
       let gadget2 = Gadget {
           id: 2,
           owner: Rc::clone(&gadget_owner),
       };
   
       // Dispose of our local variable `gadget_owner`.
       drop(gadget_owner);
   
       // Despite dropping `gadget_owner`, we're still able to print out the name
       // of the `Owner` of the `Gadget`s. This is because we've only dropped a
       // single `Rc<Owner>`, not the `Owner` it points to. As long as there are
       // other `Rc<Owner>` pointing at the same `Owner` allocation, it will remain
       // live. The field projection `gadget1.owner.name` works because
       // `Rc<Owner>` automatically dereferences to `Owner`.
       println!("Gadget {} owned by {}", gadget1.id, gadget1.owner.name);
       println!("Gadget {} owned by {}", gadget2.id, gadget2.owner.name);
   
       // At the end of the function, `gadget1` and `gadget2` are destroyed, and
       // with them the last counted references to our `Owner`. Gadget Man now
       // gets destroyed as well.
   }
   ~~~

   しかし、要求が変化してオーナーからガジェットへの移動が必要になった場合、問題が発生することになる。オーナーからガジェットへの `Rc`ポインタはサイクルを導入する。これは、それらの参照カウントが`0`になることはなく、アロケーションが破棄されることもないことを意味する。これを回避するために、`Weak`ポインタを使うことができます。

   Rustは実際には、そもそもこのループを生成することをやや難しくしている。2つの値がお互いを指すようになるためには、そのうちの1つは変更可能である必要があります。これは、`Rc`がラップした値への共有参照のみを与えることでメモリの安全性を確保しており、直接の突然変異を許さないからである。これは内部可変性を提供する`RefCell`で、共有参照を介して変異性を実現する方法。`RefCell`は実行時にRustの借用ルールを強制する。

### std::sync::Arc

  - Description

    スレッドセーフな参照カウントポインタ。`Arc`は`Atomically Reference Counted`の略。

    `Arc<T>`型は、ヒープに割り当てられた`T`型の値の共有所有権を提供する。`Arc`上で`clone`を実行すると、参照カウントを増加させながら、ソース`Arc`と同じヒープ上の割り当てを指す新しい`Arc`インスタンスが生成される。与えられたアロケーションへの最後の Arc ポインタが破棄されると、そのアロケーションに格納されている値 (多くの場合、「内部値」と呼ばれます) も削除されます。

    Rust の共有参照はデフォルトで突然変異を禁止しており、Arc も例外ではありません。Arc を通してミューテーションを行う必要がある場合は、Mutex、RwLock、または Atomic 型のいずれかを使用してください。

    Rc<T> とは異なり、Arc<T> は参照カウントにアトミック演算を使用します。これはスレッドセーフであることを意味します。欠点は、アトミック演算が通常のメモリアクセスに比べて高価なことです。スレッド間で参照カウントされた割り当てを共有しない場合は、より低いオーバーヘッドのために Rc<T> の使用を検討してください。スレッド間で Rc<T> を送ろうとすると、コンパイラがそれをキャッチするので、`Rc<T>`は安全なデフォルトです。しかし、ライブラリの利用者に柔軟性を持たせるために、ライブラリは`Arc<T>`を選択するかもしれません。

    `Arc<T>`は、`T`が`Send`と`Sync`を実装している限り、`Send`と`Sync`をする。スレッドセーフではない型の`T`を`Arc<T>`に入れてスレッドセーフにすることができないのはなぜか？最初は少し直観的ではないかもしれないが、結局のところ、`Arc<T>` のスレッドセーフは重要ではないのではないのか？結局のところ、`Arc<T>`のスレッド安全性は重要ではないのではないのか？重要なのは、`Arc<T>`は、同じデータの複数の所有権を持つことをスレッドセーフにする、そのデータにスレッドセーフを追加するわけではない。`Arc<RefCell<T>>`を考えてみる。RefCell<T>はSyncではないので、もしArc<T>が常にSendであれば、Arc<RefCell<T>も同様に`Send`になります。しかし、そうすると問題が発生する。`RefCell<T>`はスレッドセーフではない。

    `RefCell<T>`はスレッドセーフではないので、非アトミック演算を使って借用回数を追跡する。

    `downgrade`メソッドを使用して、所有権のない`Weak`ポインタを作成することができる。`Weak`ポインタを`Arc`にアップグレードすることができますが、アロケーションに格納されている値が既にドロップされている場合は`None`を返す。言い換えれば、`Weak` `ポインタはアロケーション内の値を保持しませんが、アロケーション (値の裏付けとなるストア) を保持する。

    `Arc`ポインタ間のサイクルは決して解放されない。このため、`Weak`はサイクルを壊すために使用されます。例えば、ツリーは親ノードから子ノードへの強いアークポインタを持ち、子ノードから親ノードへの弱いポインタを持つことができる。

    - Cloning
      既存の参照カウントされたポインタから新しい参照を作成するには、`Arc<T>`と`Weak<T>`に実装された`Clone`トレイトを使用します。

    ~~~rust
    use std::sync::Arc;
    let foo = Arc::new(vec![1.0, 2.0, 3.0]);
    // The two syntaxes below are equivalent.
    let a = foo.clone();
    let b = Arc::clone(&foo);
    // a, b, and foo are all Arcs that point to the same memory location
    ~~~

    - Deref behavior
      `Arc<T>`は自動的に (Deref trait を介して) `T`に派生するので、`Arc<T>`型の値に対して`T`のメソッドを呼び出すことができる。`T`のメソッドとの名前の衝突を避けるため、`Arc<T>`のメソッドは関連する関数であり、完全修飾構文を用いて呼び出される。

    ~~~rust
    use std::sync::Arc;
    
    let my_arc = Arc::new(());
    Arc::downgrade(&my_arc);
    ~~~

    `Clone` のようなトレイトの`Arc<T>`の実装も、完全修飾構文を使って呼ばれることがある。

    ~~~rust
    use std::sync::Arc;
    
    let arc = Arc::new(());
    // Method-call syntax
    let arc2 = arc.clone();
    // Fully qualified syntax
    let arc3 = Arc::clone(&arc);
    ~~~

    `Weak<T>`は、内部の値が既にドロップされている可能性があるため、`T`への自動参照は行わない。

### std::sync::atomic

- Description

  Atomic型

  アトミック型はスレッド間のプリミティブな共有メモリ通信を提供し、他の並行型の構成要素となります。
  このモジュールは、`AtomicBool`、`AtomicIsize`、`AtomicUsize`、`AtomicI8`、`AtomicU16`などを含む、選択された数のAtomic型のアトミックバージョンを定義します。Atomic型は、正しく使用されるとスレッド間の更新を同期させる操作を提供します。
  各メソッドは、その操作のためのメモリバリアの強さを表す順序を取ります。これらの順序付けは、C++20 のアトミック順序付けと同じです。詳細については、[nomicon](https://doc.rust-lang.org/stable/nomicon/atomics.html)を参照してください。
  Atomic変数はスレッド間で共有しても安全ですが（`Sync`を実装しています）、それ自体は共有のメカニズムを提供しておらず、Rustのスレッドモデルに従っています。アトミック変数を共有する最も一般的な方法は、`Arc`(原子的に参照カウントされた共有ポインタ) に格納することです。
  Atomic型は静的変数に格納され、`AtomicBool::new`のような定数初期化子を使って初期化されます。Atomic静的変数は、遅延グローバル初期化によく使われます。

### std::net::TcpListener

- Description

  TCP ソケットサーバで、接続をリッスンします。

  ソケットアドレスにバインドしてTcpListenerを作成した後、着信TCP接続をリッスンします。これらは accept を呼び出すか、incoming で返された Incoming イテレータを反復処理することで受け入れることができます。

  値がドロップされるとソケットは閉じられます。

  送信制御プロトコルはIETF RFC 793で規定されています。

  - Example

    ~~~rust
    use std::net::{TcpListener, TcpStream};
    
    fn handle_client(stream: TcpStream) {
        // ...
    }
    
    fn main() -> std::io::Result<()> {
        let listener = TcpListener::bind("127.0.0.1:80")?;
    
        // accept connections and process them serially
        for stream in listener.incoming() {
            handle_client(stream?);
        }
        Ok(())
    }
    ~~~

    

- Implementations

  - bind

    指定されたアドレスにバインドされる新しいTcpListenerを作成します。

    返されたリスナーは、接続を受け入れる準備ができています。

    ポート番号0でバインドすると、OSがこのリスナーにポートを割り当てるように要求します。割り当てられたポートは、`TcpListener::local_addr`メソッドで問い合わせることができます。

    アドレス型は`ToSocketAddrs`トレイトの任意の実装を指定することができます。具体的な例については、そのドキュメントを参照してください。

    `addr`が複数のアドレスを生成した場合、1つのアドレスが成功してリスナーを返すまで、それぞれのアドレスでバインドが試みられます。どのアドレスもリスナーの作成に成功しなかった場合、最後の試行 (最後のアドレス) から返されるエラーが返されます。

    

    - Example

      127.0.0.0.1:80 にバインドされた TCP リスナーを作成します。

      ~~~rust
      use std::net::TcpListener;
      
      let listener = TcpListener::bind("127.0.0.1:80").unwrap();
      ~~~

      127.0.0.0.1:80 にバインドされた TCP リスナーを作成します。失敗した場合は、127.0.0.0.1:443 にバインドされた TCP リスナーを作成します。

      ~~~rust
      use std::net::{SocketAddr, TcpListener};
      
      let addrs = [
          SocketAddr::from(([127, 0, 0, 1], 80)),
          SocketAddr::from(([127, 0, 0, 1], 443)),
      ];
      let listener = TcpListener::bind(&addrs[..]).unwrap();
      ~~~

  - incoming

    このリスナーで受信している接続のイテレータを返します。

    返されるイテレータは `None`を返すことはなく、相手の`SocketAddr`構造体も返しません。これを繰り返し処理することは、ループ内で`TcpListener::accept`を呼び出すことと同じです。

    - Example

      ~~~rust
      use std::net::TcpListener;
      
      let listener = TcpListener::bind("127.0.0.1:80").unwrap();
      
      for stream in listener.incoming() {
          match stream {
              Ok(stream) => {
                  println!("new client!");
              }
              Err(e) => { /* connection failed */ }
          }
      }
      ~~~

### std::net::TcpStream

- Description

  ローカルとリモートのソケット間のTCPストリーム。

  リモートホストに接続するか、TcpListener上で接続を受け付けるかのいずれかでTcpStreamを作成した後、そこに読み書きすることでデータを送信することができます。

  値をドロップした時点で接続を終了します。また、接続の読み書き部分は、シャットダウンメソッドで個別にシャットダウンすることができます。

  伝送制御プロトコルはIETF RFC 793に規定されています。

  - Example

    ~~~rust
    use std::io::prelude::*;
    use std::net::TcpStream;
    
    fn main() -> std::io::Result<()> {
        let mut stream = TcpStream::connect("127.0.0.1:34254")?;
    
        stream.write(&[1])?;
        stream.read(&mut [0; 128])?;
        Ok(())
    } // the stream is closed here
    ~~~

- 